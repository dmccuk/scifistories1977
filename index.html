wwwwwwww<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Shadowglass - Interactive World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        #location {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        
        .title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #64ffda;
        }
        
        .key {
            color: #64ffda;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="title">PROJECT SHADOWGLASS</div>
        <div style="margin-top: 20px;">Loading world...</div>
    </div>
    
    <div id="canvas-container"></div>
    
    <div id="info">
        <div class="title">PROJECT SHADOWGLASS</div>
        <div>Explore a non-linear fantasy world</div>
        <div style="margin-top: 10px; font-size: 11px; opacity: 0.8;">
            Click to start, then use controls to explore
        </div>
    </div>
    
    <div id="controls">
        <div><span class="key">WASD</span> - Move</div>
        <div><span class="key">Mouse</span> - Look around</div>
        <div><span class="key">Space</span> - Jump</div>
        <div><span class="key">Shift</span> - Sprint</div>
        <div><span class="key">T</span> - Toggle time</div>
        <div><span class="key">C</span> - Change camera view</div>
    </div>
    
    <div id="location">
        <div class="title">Location</div>
        <div id="location-name">The Coastal Meadows</div>
        <div id="coordinates" style="font-size: 10px; opacity: 0.7; margin-top: 5px;"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Pixelated retro effect
        const pixelRatio = 0.35;
        renderer.setSize(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio, false);
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.domElement.style.imageRendering = 'pixelated';
        
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        scene.fog = new THREE.Fog(0x9db4c0, 80, 400);
        
        let player = {
            position: new THREE.Vector3(-20, 5, 30),
            velocity: new THREE.Vector3(0, 0, 0),
            rotation: { x: 0, y: -Math.PI / 4 },
            speed: 0.15,
            sprintMultiplier: 2,
            jumpForce: 0.3,
            onGround: false,
            height: 2
        };
        
        camera.position.copy(player.position);
        
        const keys = {};
        let mouseMovement = { x: 0, y: 0 };
        let pointerLocked = false;
        let cameraMode = 0;
        
        let timeOfDay = 0.7;
        let timeSpeed = 0.00005;
        let autoTimeProgress = true;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffd9a0, 0.6);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -150;
        directionalLight.shadow.camera.right = 150;
        directionalLight.shadow.camera.top = 150;
        directionalLight.shadow.camera.bottom = -150;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        function createVoxel(width, height, depth, color, x, y, z, receiveShadow = true, castShadow = true) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshLambertMaterial({ 
                color: color
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = receiveShadow;
            mesh.castShadow = castShadow;
            return mesh;
        }
        
        function createGround() {
            const groundSize = 300;
            const baseGround = createVoxel(groundSize, 1, groundSize, 0x3d5a42, 0, -0.5, 0, true, false);
            scene.add(baseGround);
            
            const topGround = createVoxel(groundSize, 0.5, groundSize, 0x4a6b52, 0, 0.25, 0, true, false);
            scene.add(topGround);
            
            // Coastal beach area with sand
            const sandColors = [0xc2b280, 0xd2c290, 0xb2a270];
            for (let i = 0; i < 150; i++) {
                const size = Math.random() * 2 + 0.5;
                const x = (Math.random() - 0.5) * 60 - 20;
                const z = (Math.random() - 0.5) * 40 + 20;
                const color = sandColors[Math.floor(Math.random() * sandColors.length)];
                const sand = createVoxel(size, 0.3, size, color, x, 0.4, z);
                scene.add(sand);
            }
            
            // Grass in the distance and sides
            const grassColors = [0x4a7c59, 0x5a8c69, 0x4d7a5c, 0x567f62];
            for (let i = 0; i < 300; i++) {
                const size = Math.random() * 1.5 + 0.5;
                const x = (Math.random() - 0.5) * groundSize * 0.9;
                const z = (Math.random() - 0.5) * groundSize * 0.9;
                
                // Skip bay area
                if (z < 15 || z > 50 || x < -50 || x > 30) {
                    const color = grassColors[Math.floor(Math.random() * grassColors.length)];
                    const grassPatch = createVoxel(size, 0.3, size, color, x, 0.4, z);
                    scene.add(grassPatch);
                }
            }
            
            // Rocky shoreline details
            const rockColors = [0x6a6a5a, 0x7a7a6a, 0x5a5a4a];
            for (let i = 0; i < 50; i++) {
                const size = Math.random() * 1.5 + 0.5;
                const x = (Math.random() - 0.5) * 60 - 20;
                const z = Math.random() * 10 + 10;
                const color = rockColors[Math.floor(Math.random() * rockColors.length)];
                const rock = createVoxel(size, size * 0.8, size, color, x, 0.5, z);
                scene.add(rock);
            }
        }
        
        function createDetailedTree(x, z, size = 1) {
            const trunkHeight = 3.5 * size;
            const trunkWidth = 0.7 * size;
            
            const trunkColors = [0x4a3728, 0x3a2718, 0x5a4738];
            for (let i = 0; i < 4; i++) {
                const segHeight = trunkHeight / 4;
                const color = trunkColors[i % trunkColors.length];
                const trunk = createVoxel(
                    trunkWidth, segHeight, trunkWidth, 
                    color, 
                    x, segHeight/2 + i * segHeight, z
                );
                scene.add(trunk);
            }
            
            const foliageColors = [0x1d4010, 0x2d5016, 0x1f4812, 0x3d6b1f, 0x254a14];
            const layers = 5;
            const blocksPerLayer = 25;
            
            for (let layer = 0; layer < layers; layer++) {
                const layerRadius = (4 - layer * 0.5) * size;
                const layerHeight = trunkHeight + layer * 1.2 * size;
                
                for (let b = 0; b < blocksPerLayer; b++) {
                    const angle = (b / blocksPerLayer) * Math.PI * 2;
                    const radius = Math.random() * layerRadius;
                    const bx = x + Math.cos(angle) * radius;
                    const bz = z + Math.sin(angle) * radius;
                    const by = layerHeight + (Math.random() - 0.5) * 1.5;
                    
                    const blockSize = Math.random() * 0.8 + 0.4;
                    const color = foliageColors[Math.floor(Math.random() * foliageColors.length)];
                    
                    const foliage = createVoxel(blockSize, blockSize, blockSize, color, bx, by, bz);
                    scene.add(foliage);
                }
                
                const coreSize = layerRadius * 0.7;
                const coreColor = foliageColors[layer % foliageColors.length];
                const core = createVoxel(coreSize, 2, coreSize, coreColor, x, layerHeight, z);
                scene.add(core);
            }
        }
        
        function createAncientOak(x, z) {
            const trunkHeight = 9;
            const trunkWidth = 2.8;
            
            const trunkColors = [0x3a2718, 0x2a1708, 0x4a3728, 0x3a2720];
            for (let i = 0; i < 6; i++) {
                const segHeight = trunkHeight / 6;
                const widthVar = trunkWidth + Math.sin(i) * 0.3;
                const color = trunkColors[i % trunkColors.length];
                const trunk = createVoxel(
                    widthVar, segHeight, widthVar, 
                    color, 
                    x, segHeight/2 + i * segHeight, z
                );
                scene.add(trunk);
            }
            
            const foliageColors = [0x0d3000, 0x1d4010, 0x2d5016, 0x1a3d0e, 0x254518];
            const canopyLayers = 7;
            const blocksPerLayer = 45;
            
            for (let layer = 0; layer < canopyLayers; layer++) {
                const layerRadius = (14 - layer * 1.5);
                const layerHeight = trunkHeight + layer * 1.8;
                
                for (let b = 0; b < blocksPerLayer; b++) {
                    const angle = (b / blocksPerLayer) * Math.PI * 2 + layer * 0.5;
                    const radius = Math.random() * layerRadius;
                    const bx = x + Math.cos(angle) * radius;
                    const bz = z + Math.sin(angle) * radius;
                    const by = layerHeight + (Math.random() - 0.5) * 2;
                    
                    const blockSize = Math.random() * 1.2 + 0.5;
                    const color = foliageColors[Math.floor(Math.random() * foliageColors.length)];
                    
                    const foliage = createVoxel(blockSize, blockSize, blockSize, color, bx, by, bz);
                    scene.add(foliage);
                }
                
                const coreSize = layerRadius * 0.6;
                const core = createVoxel(coreSize, 3, coreSize, foliageColors[1], x, layerHeight, z);
                scene.add(core);
            }
            
            const platformCount = 8;
            for (let i = 0; i < platformCount; i++) {
                const angle = (i / platformCount) * Math.PI * 3;
                const radius = 3.5;
                const px = x + Math.cos(angle) * radius;
                const pz = z + Math.sin(angle) * radius;
                const py = 2 + i * 1.3;
                
                const platform = createVoxel(2.5, 0.4, 2.5, 0x8b7355, px, py, pz);
                scene.add(platform);
            }
        }
        
        function createCottage(x, z) {
            const wallColors = [0x8b6f47, 0x7b5f37, 0x9b7f57];
            
            for (let i = 0; i < 3; i++) {
                const base = createVoxel(6, 1, 5, wallColors[i % 3], x, 0.5 + i, z);
                scene.add(base);
            }
            
            const roofColors = [0x6d4c3b, 0x5d3c2b, 0x7d5c4b];
            for (let i = 0; i < 3; i++) {
                const width = 7 - i * 0.5;
                const depth = 6 - i * 0.5;
                const roof = createVoxel(width, 0.5, depth, roofColors[i], x, 3.5 + i * 0.5, z);
                scene.add(roof);
            }
            
            const door = createVoxel(1.2, 2, 0.2, 0x4a3728, x, 1.5, z - 2.6);
            scene.add(door);
            
            const windowPositions = [[-2, 2, -2.5], [2, 2, -2.5]];
            windowPositions.forEach(([wx, wy, wz]) => {
                const window = createVoxel(1, 1, 0.15, 0x6ba3d4, x + wx, wy, z + wz, false, false);
                scene.add(window);
                
                const light = new THREE.PointLight(0xffdb99, 0.6, 12);
                light.position.set(x + wx, wy, z + wz);
                scene.add(light);
            });
        }
        
        // Create a sailing ship
        function createShip(x, z) {
            // Hull - main body
            const hullColors = [0x4a3728, 0x5a4738, 0x3a2718];
            
            // Bottom hull
            for (let i = 0; i < 3; i++) {
                const width = 8 - i * 1.5;
                const hull = createVoxel(width, 2, 12, hullColors[i % 3], x, 1.5 + i * 2, z);
                scene.add(hull);
            }
            
            // Deck
            const deck = createVoxel(7, 0.5, 11, 0x8b7355, x, 7.5, z);
            scene.add(deck);
            
            // Cabin
            const cabin = createVoxel(5, 3, 6, 0x6a5a4a, x, 9.5, z - 2);
            scene.add(cabin);
            
            const cabinRoof = createVoxel(5.5, 0.8, 6.5, 0x5a4a3a, x, 11.5, z - 2);
            scene.add(cabinRoof);
            
            // Masts
            const mainMast = createVoxel(0.6, 18, 0.6, 0x4a3728, x, 17, z);
            scene.add(mainMast);
            
            const frontMast = createVoxel(0.5, 14, 0.5, 0x4a3728, x, 14, z + 4);
            scene.add(frontMast);
            
            // Sails - white/cream colored
            const sailColor = 0xf5f5dc;
            
            // Main sail
            const mainSail = createVoxel(8, 10, 0.3, sailColor, x, 17, z);
            scene.add(mainSail);
            
            // Front sail
            const frontSail = createVoxel(6, 8, 0.3, sailColor, x, 14, z + 4);
            scene.add(frontSail);
            
            // Bow (front point)
            const bow = createVoxel(2, 3, 3, 0x4a3728, x, 3, z + 7);
            scene.add(bow);
            
            // Add some details - railings
            for (let i = -5; i <= 5; i += 2) {
                const railing = createVoxel(0.3, 0.8, 0.3, 0x3a2718, x + 3.5, 8, z + i);
                const railing2 = createVoxel(0.3, 0.8, 0.3, 0x3a2718, x - 3.5, 8, z + i);
                scene.add(railing);
                scene.add(railing2);
            }
            
            // Flags on masts
            const flag = createVoxel(2, 1.5, 0.2, 0xff4444, x + 1, 25, z);
            scene.add(flag);
        }
        
        function createCastle(x, z) {
            // Large multi-level foundation
            const foundationLayers = [
                {size: 28, height: 3, color: 0x5a4e3f, y: 1.5},
                {size: 26, height: 2, color: 0x6a5e4f, y: 3.5},
                {size: 24, height: 1.5, color: 0x7a6e5f, y: 5}
            ];
            
            foundationLayers.forEach(layer => {
                const base = createVoxel(layer.size, layer.height, layer.size, layer.color, x, layer.y, z);
                scene.add(base);
            });
            
            // Main keep - taller and more detailed
            const keepWidth = 18;
            const keepLayers = 20;
            for (let i = 0; i < keepLayers; i++) {
                const keepColor = i % 2 === 0 ? 0x7a6e5f : 0x6a5e4f;
                const keep = createVoxel(keepWidth, 2, keepWidth, keepColor, x, 7 + i * 2, z);
                scene.add(keep);
            }
            
            // Battlements on main keep
            for (let bx = -8; bx <= 8; bx += 4) {
                for (let bz = -8; bz <= 8; bz += 4) {
                    if (Math.abs(bx) === 8 || Math.abs(bz) === 8) {
                        const battlement = createVoxel(1.5, 2, 1.5, 0x5a4e3f, x + bx, 48, z + bz);
                        scene.add(battlement);
                    }
                }
            }
            
            // Four corner towers - very tall
            const towerPositions = [[-9, -9], [9, -9], [-9, 9], [9, 9]];
            towerPositions.forEach(([ox, oz]) => {
                // Tower body
                for (let i = 0; i < 20; i++) {
                    const towerColor = i % 2 === 0 ? 0x8a7e6f : 0x7a6e5f;
                    const tower = createVoxel(5, 2.5, 5, towerColor, x + ox, 7 + i * 2.5, z + oz);
                    scene.add(tower);
                }
                
                // Tower cap
                const cap = createVoxel(6, 2.5, 6, 0x6a5e4f, x + ox, 58, z + oz);
                scene.add(cap);
                
                // Detailed battlements
                for (let b = 0; b < 8; b++) {
                    const angle = (b / 8) * Math.PI * 2;
                    const bx = ox + Math.cos(angle) * 2.5;
                    const bz = oz + Math.sin(angle) * 2.5;
                    const battlement = createVoxel(0.8, 1.8, 0.8, 0x5a4e3f, x + bx, 60, z + bz);
                    scene.add(battlement);
                }
                
                // Tall spires
                for (let s = 0; s < 5; s++) {
                    const spireSize = 1.5 - s * 0.2;
                    const spire = createVoxel(spireSize, 2, spireSize, 0x9a8e7f, x + ox, 61 + s * 2, z + oz);
                    scene.add(spire);
                }
            });
            
            // Central main spire - extremely tall
            for (let i = 0; i < 12; i++) {
                const spireSize = 3 - i * 0.15;
                const spireColor = i % 2 === 0 ? 0x8a7e6f : 0x7a6e5f;
                const mainSpire = createVoxel(spireSize, 2.5, spireSize, spireColor, x, 48 + i * 2.5, z);
                scene.add(mainSpire);
            }
            
            // Spire top
            for (let i = 0; i < 3; i++) {
                const topSize = 2 - i * 0.5;
                const top = createVoxel(topSize, 2, topSize, 0x9a8e7f, x, 78 + i * 2, z);
                scene.add(top);
            }
            
            // Large cross at top
            const crossV = createVoxel(0.8, 6, 0.8, 0x6a5e4f, x, 87, z);
            const crossH = createVoxel(3.5, 0.8, 0.8, 0x6a5e4f, x, 85, z);
            scene.add(crossV);
            scene.add(crossH);
            
            // Many lit windows in a grid pattern
            const windowGrid = [];
            
            // Front face windows
            for (let floor = 0; floor < 8; floor++) {
                for (let col = -6; col <= 6; col += 3) {
                    windowGrid.push([col, 12 + floor * 5, -9.1]);
                }
            }
            
            // Side faces
            for (let floor = 0; floor < 8; floor++) {
                windowGrid.push([-9.1, 12 + floor * 5, 0]);
                windowGrid.push([9.1, 12 + floor * 5, 0]);
                windowGrid.push([-9.1, 12 + floor * 5, 6]);
                windowGrid.push([9.1, 12 + floor * 5, 6]);
                windowGrid.push([-9.1, 12 + floor * 5, -6]);
                windowGrid.push([9.1, 12 + floor * 5, -6]);
            }
            
            // Tower windows
            towerPositions.forEach(([ox, oz]) => {
                for (let floor = 0; floor < 10; floor++) {
                    windowGrid.push([ox, 12 + floor * 5, oz > 0 ? oz + 2.6 : oz - 2.6]);
                    windowGrid.push([ox > 0 ? ox + 2.6 : ox - 2.6, 12 + floor * 5, oz]);
                }
            });
            
            windowGrid.forEach(([wx, wy, wz]) => {
                const window = createVoxel(1.5, 2.2, 0.2, 0xffdb99, x + wx, wy, z + wz, false, false);
                scene.add(window);
                
                // Warm glow
                const light = new THREE.PointLight(0xffdb99, 1.2, 20);
                light.position.set(x + wx, wy, z + wz);
                scene.add(light);
            });
            
            // Additional colored windows (green/red accents)
            const accentWindows = [
                [0, 35, -9.1, 0x90ee90],
                [-3, 35, -9.1, 0xff6b6b],
                [3, 35, -9.1, 0xff6b6b]
            ];
            
            accentWindows.forEach(([wx, wy, wz, color]) => {
                const window = createVoxel(1.8, 2.5, 0.2, color, x + wx, wy, z + wz, false, false);
                scene.add(window);
                
                const light = new THREE.PointLight(color, 0.8, 15);
                light.position.set(x + wx, wy, z + wz);
                scene.add(light);
            });
        }
        
        function createWater() {
            // Large bay water
            const waterLayers = [
                {width: 150, depth: 200, color: 0x4a7a8d, opacity: 0.5, y: -0.3},
                {width: 145, depth: 195, color: 0x5b8fa3, opacity: 0.6, y: 0},
                {width: 140, depth: 190, color: 0x6b9fb3, opacity: 0.4, y: 0.2}
            ];
            
            waterLayers.forEach(layer => {
                const waterGeometry = new THREE.PlaneGeometry(layer.width, layer.depth);
                const waterMaterial = new THREE.MeshLambertMaterial({ 
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity
                });
                const water = new THREE.Mesh(waterGeometry, waterMaterial);
                water.rotation.x = -Math.PI / 2;
                water.position.set(20, layer.y, -30);
                water.receiveShadow = true;
                scene.add(water);
            });
            
            // Water surface details - ripples
            for (let i = 0; i < 100; i++) {
                const size = Math.random() * 2 + 0.3;
                const x = 20 + (Math.random() - 0.5) * 140;
                const z = -30 + (Math.random() - 0.5) * 180;
                const color = Math.random() > 0.5 ? 0x7bafbf : 0x8bbfcf;
                const ripple = createVoxel(size, 0.08, size, color, x, 0.15, z, false, false);
                scene.add(ripple);
            }
        }
        
        function buildWorld() {
            createGround();
            
            // Ship in the bay
            createShip(0, 5);
            
            // A few coastal trees
            const coastalTrees = [
                [-35, 25, 1.0], [-30, 30, 0.9], [-40, 28, 1.1],
                [-25, 35, 0.95], [15, 25, 1.0], [20, 30, 0.9]
            ];
            coastalTrees.forEach(([x, z, size]) => createDetailedTree(x, z, size));
            
            // Ancient oak on a hill nearby
            createAncientOak(-45, 40);
            
            // Distant forest
            const distantTrees = [
                [-60, -20, 1.1], [-55, -25, 1.0], [-50, -30, 1.2],
                [-65, -15, 0.9], [40, -20, 1.0], [45, -25, 0.95],
                [50, -30, 1.1], [35, -35, 1.0]
            ];
            distantTrees.forEach(([x, z, size]) => createDetailedTree(x, z, size));
            
            // Bay water
            createWater();
            
            // Castle in the far distance across the bay
            createCastle(40, -100);
            
            document.getElementById('loading').classList.add('hidden');
        }
        
        function updateSkyColor() {
            let skyColor, fogColor, sunColor;
            
            if (timeOfDay < 0.25) {
                const t = timeOfDay / 0.25;
                skyColor = lerpColor(0x1a1a2e, 0x4a5d7c, t);
                fogColor = lerpColor(0x2a2a3e, 0x6a7d9c, t);
                sunColor = 0x6a7a9c;
            } else if (timeOfDay < 0.5) {
                const t = (timeOfDay - 0.25) / 0.25;
                skyColor = lerpColor(0x4a5d7c, 0x87ceeb, t);
                fogColor = lerpColor(0x6a7d9c, 0x9db4c0, t);
                sunColor = lerpColor(0x6a7a9c, 0xffd9a0, t);
            } else if (timeOfDay < 0.75) {
                const t = (timeOfDay - 0.5) / 0.25;
                skyColor = lerpColor(0x87ceeb, 0x7d5a8c, t);
                fogColor = lerpColor(0x9db4c0, 0x8d7a9c, t);
                sunColor = lerpColor(0xffd9a0, 0xff9a80, t);
            } else {
                const t = (timeOfDay - 0.75) / 0.25;
                skyColor = lerpColor(0x7d5a8c, 0x1a1a2e, t);
                fogColor = lerpColor(0x8d7a9c, 0x2a2a3e, t);
                sunColor = 0x4a5a7c;
            }
            
            scene.background = new THREE.Color(skyColor);
            scene.fog.color.setHex(fogColor);
            directionalLight.color.setHex(sunColor);
            
            const sunAngle = timeOfDay * Math.PI * 2;
            directionalLight.position.set(
                Math.cos(sunAngle) * 50,
                Math.sin(sunAngle) * 50,
                30
            );
        }
        
        function lerpColor(color1, color2, t) {
            const r1 = (color1 >> 16) & 0xff;
            const g1 = (color1 >> 8) & 0xff;
            const b1 = color1 & 0xff;
            
            const r2 = (color2 >> 16) & 0xff;
            const g2 = (color2 >> 8) & 0xff;
            const b2 = color2 & 0xff;
            
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            
            return (r << 16) | (g << 8) | b;
        }
        
        function getLocationName(x, z) {
            if (Math.abs(x + 20) < 15 && z > 15 && z < 40) {
                return "The Coastal Bay";
            } else if (Math.abs(x) < 30 && z > 0 && z < 15) {
                return "The Ship's Anchor";
            } else if (x < -30 && z > 20) {
                return "The Coastal Forest";
            } else if (z < -50) {
                return "View to Castle Isle";
            } else {
                return "The Shoreline";
            }
        }
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 't') {
                autoTimeProgress = !autoTimeProgress;
            }
            
            if (e.key.toLowerCase() === 'c') {
                cameraMode = (cameraMode + 1) % 2;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });
        
        document.addEventListener('click', () => {
            if (!pointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        });
        
        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === renderer.domElement;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (pointerLocked) {
                mouseMovement.x += e.movementX;
                mouseMovement.y += e.movementY;
            }
        });
        
        function updatePlayer() {
            player.rotation.y -= mouseMovement.x * 0.002;
            player.rotation.x -= mouseMovement.y * 0.002;
            player.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.x));
            mouseMovement.x = 0;
            mouseMovement.y = 0;
            
            const speed = keys['shift'] ? player.speed * player.sprintMultiplier : player.speed;
            const forward = new THREE.Vector3(
                Math.sin(player.rotation.y),
                0,
                Math.cos(player.rotation.y)
            );
            const right = new THREE.Vector3(
                Math.cos(player.rotation.y),
                0,
                -Math.sin(player.rotation.y)
            );
            
            if (keys['w']) player.velocity.add(forward.multiplyScalar(-speed));
            if (keys['s']) player.velocity.add(forward.multiplyScalar(speed));
            if (keys['a']) player.velocity.add(right.multiplyScalar(-speed));
            if (keys['d']) player.velocity.add(right.multiplyScalar(speed));
            
            if (keys[' '] && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false;
            }
            
            player.velocity.y -= 0.015;
            player.position.add(player.velocity);
            
            if (player.position.y <= player.height) {
                player.position.y = player.height;
                player.velocity.y = 0;
                player.onGround = true;
            }
            
            player.velocity.x *= 0.8;
            player.velocity.z *= 0.8;
            
            if (cameraMode === 0) {
                camera.position.copy(player.position);
                camera.rotation.x = player.rotation.x;
                camera.rotation.y = player.rotation.y;
            } else {
                const distance = 8;
                const offset = new THREE.Vector3(
                    Math.sin(player.rotation.y) * distance,
                    3,
                    Math.cos(player.rotation.y) * distance
                );
                camera.position.copy(player.position).sub(offset);
                camera.lookAt(player.position);
            }
            
            const locationName = getLocationName(player.position.x, player.position.z);
            document.getElementById('location-name').textContent = locationName;
            document.getElementById('coordinates').textContent = 
                `X: ${player.position.x.toFixed(1)} Z: ${player.position.z.toFixed(1)}`;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            
            if (autoTimeProgress) {
                timeOfDay = (timeOfDay + timeSpeed) % 1;
            }
            updateSkyColor();
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        buildWorld();
        updateSkyColor();
        animate();
    </script>
</body>
</html>
